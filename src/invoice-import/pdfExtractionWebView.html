<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PDF Extraction Bridge</title>
<style>
  /* Hidden page — no visible UI. Canvas elements created dynamically for image extraction. */
  body { margin: 0; padding: 0; background: transparent; }
  canvas { display: none; }
</style>
</head>
<body>
<script type="module">
/**
 * PDF Extraction WebView Bridge
 *
 * This self-contained HTML file runs inside a hidden React Native WebView.
 * It loads pdfjs-dist from CDN and provides text extraction (with line
 * reconstruction) and embedded image extraction via postMessage.
 *
 * NOTE: pdfjs-dist is loaded at runtime from CDN. This requires network
 * connectivity the first time the WebView loads. To support full offline
 * operation, the pdfjs-dist files could instead be bundled as local assets
 * and loaded via require() / expo-asset.
 */

// ---------------------------------------------------------------------------
// pdf.js setup (legacy build for broad compatibility)
// ---------------------------------------------------------------------------

// We use the legacy build and the ES module entry so we can import directly.
// The CDN URL uses the 4.x legacy build which supports older JS engines.
const PDFJS_VERSION = '4.0.379';
const PDFJS_CDN = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${PDFJS_VERSION}`;

let pdfjsLib = null;

async function loadPdfJs() {
  try {
    pdfjsLib = await import(`${PDFJS_CDN}/pdf.min.mjs`);
    pdfjsLib.GlobalWorkerOptions.workerSrc = `${PDFJS_CDN}/pdf.worker.min.mjs`;
  } catch (_e1) {
    // Fallback: try the non-.mjs legacy build loaded via a script tag
    // Some WebView engines may not support dynamic import of cross-origin modules.
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = `${PDFJS_CDN}/pdf.min.js`;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
    // The UMD build exposes pdfjsLib on window
    pdfjsLib = window.pdfjsLib;
    if (!pdfjsLib) throw new Error('Failed to load pdf.js from CDN');
    pdfjsLib.GlobalWorkerOptions.workerSrc = `${PDFJS_CDN}/pdf.worker.min.js`;
  }
}

// ---------------------------------------------------------------------------
// Text extraction — buildTextLinesFromPdfTextItems
// Matches the web app's pdfTextExtraction.ts exactly.
// ---------------------------------------------------------------------------

function isTextItem(item) {
  return item != null && typeof item === 'object' && 'str' in item;
}

function getItemXY(item) {
  const t = item.transform;
  if (Array.isArray(t) && t.length >= 6) {
    const x = Number(t[4]);
    const y = Number(t[5]);
    return {
      x: Number.isFinite(x) ? x : 0,
      y: Number.isFinite(y) ? y : 0,
    };
  }
  return { x: 0, y: 0 };
}

/**
 * Reconstructs human-readable lines from pdfjs TextItem tokens by grouping
 * tokens sharing the same Y coordinate (within a tolerance) and sorting
 * left-to-right within each line.
 */
function buildTextLinesFromPdfTextItems(items) {
  const tokens = items
    .map((it) => ({ str: (it.str || '').trim(), ...getItemXY(it) }))
    .filter(t => t.str.length > 0);

  if (tokens.length === 0) return '';

  // Sort top-to-bottom (higher y first), then left-to-right.
  tokens.sort((a, b) => (b.y - a.y) || (a.x - b.x));

  const yTolerance = 2; // PDF coordinate fuzz; keeps same visual row together.
  const lines = [];

  for (const t of tokens) {
    const last = lines[lines.length - 1];
    if (!last || Math.abs(last.y - t.y) > yTolerance) {
      lines.push({ y: t.y, parts: [{ x: t.x, str: t.str }] });
    } else {
      last.parts.push({ x: t.x, str: t.str });
    }
  }

  return lines
    .map(line => {
      line.parts.sort((a, b) => a.x - b.x);
      return line.parts.map(p => p.str).join(' ').replace(/\s+/g, ' ').trim();
    })
    .filter(Boolean)
    .join('\n');
}

async function extractPdfText(pdfData) {
  const startTime = performance.now();
  const loadingTask = pdfjsLib.getDocument({ data: pdfData });
  const pdf = await loadingTask.promise;

  const pages = [];

  for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
    const page = await pdf.getPage(pageNumber);
    const content = await page.getTextContent();
    const pageItems = content.items.filter(isTextItem);
    const pageText = buildTextLinesFromPdfTextItems(pageItems);
    pages.push(pageText);
  }

  const fullText = pages.join('\n\n');
  const durationMs = Math.round(performance.now() - startTime);

  return {
    pages,
    fullText,
    stats: {
      pageCount: pdf.numPages,
      charCount: fullText.length,
      lineCount: fullText.split('\n').length,
      durationMs,
    },
  };
}

// ---------------------------------------------------------------------------
// Image extraction — embedded image extraction with scoring/filtering
// Matches the web app's pdfEmbeddedImageExtraction.ts logic.
// ---------------------------------------------------------------------------

function multiplyMatrices(m1, m2) {
  const [a1, b1, c1, d1, e1, f1] = m1;
  const [a2, b2, c2, d2, e2, f2] = m2;
  return [
    a1 * a2 + c1 * b2,
    b1 * a2 + d1 * b2,
    a1 * c2 + c1 * d2,
    b1 * c2 + d1 * d2,
    a1 * e2 + c1 * f2 + e1,
    b1 * e2 + d1 * f2 + f1,
  ];
}

function bboxFromMatrix(m) {
  const [a, b, c, d, e, f] = m;
  const p0 = { x: e, y: f };
  const p1 = { x: a + e, y: b + f };
  const p2 = { x: c + e, y: d + f };
  const p3 = { x: a + c + e, y: b + d + f };

  const xMin = Math.min(p0.x, p1.x, p2.x, p3.x);
  const xMax = Math.max(p0.x, p1.x, p2.x, p3.x);
  const yMin = Math.min(p0.y, p1.y, p2.y, p3.y);
  const yMax = Math.max(p0.y, p1.y, p2.y, p3.y);
  return { xMin, xMax, yMin, yMax };
}

const DEFAULT_IMAGE_OPTIONS = {
  pdfBoxSizeFilter: { min: 15, max: 180 },
  xMinMax: 220,
  maxAspectRatio: 2.3,
  renderScale: 2,
  minArea: 4000,
};

async function extractPdfImages(pdfData, options = {}) {
  const startTime = performance.now();
  const loadingTask = pdfjsLib.getDocument({ data: pdfData });
  const pdf = await loadingTask.promise;

  const pdfBoxSizeFilter = options.pdfBoxSizeFilter || DEFAULT_IMAGE_OPTIONS.pdfBoxSizeFilter;
  const xMinMax = options.xMinMax ?? DEFAULT_IMAGE_OPTIONS.xMinMax;
  const renderScale = options.renderScale ?? DEFAULT_IMAGE_OPTIONS.renderScale;
  const maxAspectRatio = options.maxAspectRatio ?? DEFAULT_IMAGE_OPTIONS.maxAspectRatio;
  const minArea = options.minArea ?? DEFAULT_IMAGE_OPTIONS.minArea;

  const OPS = pdfjsLib.OPS;
  const results = [];

  for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
    const page = await pdf.getPage(pageNumber);
    const operatorList = await page.getOperatorList();
    const { fnArray, argsArray } = operatorList;

    const candidateBboxes = [];

    const matrixStack = [];
    let ctm = [1, 0, 0, 1, 0, 0];

    for (let i = 0; i < fnArray.length; i++) {
      const fn = fnArray[i];
      const args = argsArray[i];

      if (fn === OPS.save) {
        matrixStack.push(ctm.slice());
        continue;
      }
      if (fn === OPS.restore) {
        const prev = matrixStack.pop();
        if (prev) ctm = prev;
        continue;
      }
      if (fn === OPS.transform && Array.isArray(args) && args.length >= 6) {
        const m2 = args.slice(0, 6).map(n => Number(n));
        if (m2.every(n => Number.isFinite(n))) {
          ctm = multiplyMatrices(ctm, m2);
        }
        continue;
      }

      // paintImageXObject / inline / repeat
      if (fn === OPS.paintImageXObject && Array.isArray(args) && typeof args[0] === 'string') {
        const bbox = bboxFromMatrix(ctm);
        const wPts = Math.abs(bbox.xMax - bbox.xMin);
        const hPts = Math.abs(bbox.yMax - bbox.yMin);

        const aspectRatio = Math.max(wPts, hPts) / Math.max(1, Math.min(wPts, hPts));
        if (
          wPts >= pdfBoxSizeFilter.min &&
          wPts <= pdfBoxSizeFilter.max &&
          hPts >= pdfBoxSizeFilter.min &&
          hPts <= pdfBoxSizeFilter.max &&
          bbox.xMin <= xMinMax &&
          aspectRatio <= maxAspectRatio
        ) {
          candidateBboxes.push({ bbox });
        }
      }
    }

    if (candidateBboxes.length > 0) {
      try {
        const viewport = page.getViewport({ scale: renderScale });
        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = Math.max(1, Math.floor(viewport.width));
        pageCanvas.height = Math.max(1, Math.floor(viewport.height));
        const pageCtx = pageCanvas.getContext('2d');
        if (!pageCtx) throw new Error('Failed to get canvas 2d context for page render');

        await page.render({ canvasContext: pageCtx, viewport }).promise;

        for (const { bbox } of candidateBboxes) {
          const [x1, y1, x2, y2] = viewport.convertToViewportRectangle([bbox.xMin, bbox.yMin, bbox.xMax, bbox.yMax]);
          const left = Math.max(0, Math.floor(Math.min(x1, x2)));
          const top = Math.max(0, Math.floor(Math.min(y1, y2)));
          const right = Math.min(pageCanvas.width, Math.ceil(Math.max(x1, x2)));
          const bottom = Math.min(pageCanvas.height, Math.ceil(Math.max(y1, y2)));
          const cropW = right - left;
          const cropH = bottom - top;
          if (cropW <= 0 || cropH <= 0) continue;

          // Apply minArea filter
          const area = cropW * cropH;
          if (area < minArea) continue;

          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = cropW;
          cropCanvas.height = cropH;
          const cropCtx = cropCanvas.getContext('2d');
          if (!cropCtx) continue;

          cropCtx.drawImage(pageCanvas, left, top, cropW, cropH, 0, 0, cropW, cropH);

          const dataUri = cropCanvas.toDataURL('image/png');

          // Score: larger images score higher, penalize extreme aspect ratios
          const wPts = Math.abs(bbox.xMax - bbox.xMin);
          const hPts = Math.abs(bbox.yMax - bbox.yMin);
          const areaScore = wPts * hPts;
          const ar = Math.max(wPts, hPts) / Math.max(1, Math.min(wPts, hPts));
          const arPenalty = ar > 1.5 ? (1.0 / ar) : 1.0;
          const score = areaScore * arPenalty;

          results.push({
            dataUri,
            pageNumber,
            bbox,
            pageHeight: viewport.height / renderScale,
            score: Math.round(score * 100) / 100,
          });
        }

        // Clean up page canvas
        pageCanvas.width = 0;
        pageCanvas.height = 0;
      } catch (e) {
        console.warn('Failed to render/crop embedded images for page', pageNumber, e);
      }
    }
  }

  // Stable reading order: page asc, y desc, x asc
  results.sort((a, b) => {
    if (a.pageNumber !== b.pageNumber) return a.pageNumber - b.pageNumber;
    const ay = a.bbox.yMax;
    const by = b.bbox.yMax;
    if (ay !== by) return by - ay;
    return a.bbox.xMin - b.bbox.xMin;
  });

  return results;
}

// ---------------------------------------------------------------------------
// Message handling — bridge between React Native and extraction functions
// ---------------------------------------------------------------------------

function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

function sendMessage(data) {
  try {
    if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
      window.ReactNativeWebView.postMessage(JSON.stringify(data));
    }
  } catch (e) {
    console.error('Failed to send message to React Native:', e);
  }
}

function sendError(id, error) {
  sendMessage({
    id,
    type: 'error',
    error: {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    },
  });
}

async function handleMessage(event) {
  let msg;
  try {
    msg = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
  } catch {
    return; // Ignore non-JSON messages
  }

  const { id, type, pdfBase64, imageOptions } = msg;
  if (!id || !type) return;

  try {
    if (!pdfjsLib) {
      throw new Error('pdf.js is not loaded yet');
    }

    const pdfData = base64ToUint8Array(pdfBase64);

    if (type === 'extract-text') {
      const result = await extractPdfText(pdfData);
      sendMessage({ id, type: 'text-result', result });
    } else if (type === 'extract-images') {
      const result = await extractPdfImages(pdfData, imageOptions || {});
      sendMessage({ id, type: 'images-result', result });
    } else if (type === 'extract-text-and-images') {
      const [textResult, imagesResult] = await Promise.all([
        extractPdfText(pdfData),
        extractPdfImages(pdfData, imageOptions || {}),
      ]);
      sendMessage({
        id,
        type: 'text-and-images-result',
        result: { text: textResult, images: imagesResult },
      });
    } else {
      sendError(id, new Error(`Unknown extraction type: ${type}`));
    }
  } catch (e) {
    sendError(id, e);
  }
}

// Listen for messages from React Native
document.addEventListener('message', handleMessage);
window.addEventListener('message', handleMessage);

// ---------------------------------------------------------------------------
// Initialization
// ---------------------------------------------------------------------------

async function init() {
  try {
    await loadPdfJs();
    sendMessage({ type: 'ready' });
  } catch (e) {
    sendMessage({
      type: 'error',
      error: {
        message: 'Failed to initialize pdf.js: ' + (e instanceof Error ? e.message : String(e)),
        stack: e instanceof Error ? e.stack : undefined,
      },
    });
  }
}

init();
</script>
</body>
</html>
